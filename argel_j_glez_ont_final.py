# -*- coding: utf-8 -*-
"""Argel J. Glez Ont Final

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10Mzhoh9WxN8vF4LQS9Px1YZ7Xf-UTpe0

# Two sum
"""

#Argel Jhamir Gonzalez Ontiveros
#14571

#Ejercicio: Two Sum optimizado
#Es lento pero podria ser mas ya que usa o(n) y no o(n2) lo que lo hace mas rapido
from typing import List
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        mapa = {}

        for i, num in enumerate(nums):# Enumeramos los números para obtener tanto el índice como el valor
            complemento = target - num

            # Si el complemento ya está en el mapa, devolvemos los índices
            if complemento in mapa:
                return [mapa[complemento], i]

            # Guardamos el valor actual y su índice
            mapa[num] = i

solu=Solution()
nums= [3,8,12,15,7]
target=19
resultado=solu.twoSum(nums,target)
print(resultado)

#Argel Jhamir Gonzalez Ontiveros
#14571

#Twosum: Fuerza Bruta
#Complejidad: O(n2) ya que hace mas interaciones que en el que usamos hash por lo que es menos eficiente.

from typing import List

class Solution:
    def twosum(self, nums: list[int], target: int) -> List[int]:
        # Recorre cada número en la lista
        for i in range(len(nums)):
            # Recorre los números siguientes al actual (para no repetir combinaciones)
            for j in range(i + 1, len(nums)):
                # Si la suma de los dos números es igual al objetivo
                if nums[j] == target - nums[i]:
                    return [i, j]  # Devuelve los índices encontrados

solu = Solution()
nums = [3, 8, 12, 15, 7]
target = 19
resultado = solu.twosum(nums, target)
print(resultado)

"""#Palindrome Numbers

"""

#Argel Jhamir Gonzalez Ontiveros
#14571

# Ejercicio: Plindromos
#complejidad: O(n) ya que recorre el string una vez para verificar si es palíndromo.
class Solution:
    def is_palindrome(self, z: int):  # Recibe un número entero
        zstr = str(z)  # Convierte el número a string
        if zstr == zstr[::-1]:  # Compara con el string invertido
            return True  # Es palíndromo
        else:
            return False  # No es palíndromo

play = Solution()
solu = play.is_palindrome(235532)
print(solu)

#Argel Jhamir Gonzalez Ontiveros
#14571

# Ejercicio: Plindromos optimizado
#complejidad: O(log10n) lo cual lo hace mas eficiente
class Solution:
    def is_palindrome(self, x: int) -> bool:
        if x < 0:
            return False  # Los negativos no pueden ser palíndromos

        original = x
        reversed_num = 0

        # Invertimos el número
        while x > 0:
            digit = x % 10  # Tomamos el último dígito
            reversed_num = reversed_num * 10 + digit  # Lo agregamos al nuevo número
            x = x // 10  # Quitamos el último dígito

        return original == reversed_num  # Comparamos original con su invers



solu=Solution()
resultado=solu.is_palindrome(235532)
print(resultado)

"""# Remove Element

"""

#Argel Jhamir Gonzalez Ontiveros
#14571

#removeelement: Fuerza Bruta
#Complejidad: O(n) por lo que no es eeficiente pero es funcional


class Solution:
    def removeElement(self, nums: list[int], value: int) -> int:
        nueva = []  # Lista vacía donde guardamos los valores válidos

        for num in nums:  # Recorremos cada número en la lista
            if num != value:  # Si el número NO es el que queremos eliminar
                nueva.append(num)  # Lo agregamos a la nueva lista

        return len(nueva), nueva  # Devolvemos la cantidad y la nueva lista limpia

solu = Solution()
nums = [3, 2, 2, 3]
value = 3
resultado = solu.removeElement(nums, value)
print(resultado)

#Argel Jhamir Gonzalez Ontiveros
#14571

#removeelement: optimizado
#Complejidad: O(n) por lo que no es eficiente pero es funcional igual al fuerza bruta pero con menos memoria


class Solution:
    def removeElement(self, nums: list[int], value: int) -> int:
        pos = 0  # Índice donde vamos guardando los valores válidos

        for i in range(len(nums)):  # Recorremos la lista
            if nums[i] != value:  # Si el valor actual no es el que queremos eliminar
                nums[pos] = nums[i]  # Lo guardamos en la posición válida
                pos += 1  # Avanzamos la posición para el siguiente

        return pos, nums[:pos]  # Retornamos la longitud y la lista válida

solu = Solution()
nums = [3, 2, 2, 3]
value = 3
resultado = solu.removeElement(nums, value)
print(resultado)

"""# Length of Last Word"""

#Argel Jhamir Gonzalez Ontiveros
#14571

#removeelement: fuerza bruta
#Complejidad: O(n) lo que quiere decir que es poco eficiente con listas grandes y espacio o(n) por el split


class Solution:
    def lenghtOfLastWord(self, s: str) -> int:

        palabras = s.split()  #separamos palabras
        return len(palabras[-1])  # Tomamos la última y medimos su longitud

solu = Solution()
resultado = solu.lenghtOfLastWord("Hola mia lola abecedario")
print(resultado)

#Argel Jhamir Gonzalez Ontiveros
#14571

#lenghtofLastWord: optimizado
#Complejidad: O(n) lo que quiere decir que es poco eficiente con listas grandes y espacio o(1) por que usa variables simples


class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        i = len(s) - 1  # Empezamos desde el final del string
        longitud = 0    # Contador de letras

        while i >= 0 and s[i] == " ":  # Saltamos espacios finales
            i -= 1

        while i >= 0 and s[i] != " ":  # Contamos letras de la última palabra
            longitud += 1
            i -= 1

        return longitud  # Devolvemos la longitud final

solu = Solution()
resultado = solu.lengthOfLastWord("Hola mia lola abecedario ")
print(resultado)  # Debería imprimir 5, que es la longitud de "mundo"

"""# Plus one"""

# Argel Jhamir Gonzalez Ontiveros
# 14571

# plusOne: fuerza bruta
# Complejidad: O(n) tiempopor que tenemos que recorrer el arreglo, O(n) espacio por conversión y split

class Solution:
    def plusOne(self, digits: list[int]) -> list[int]:
        digtstsint = int(''.join(map(str, digits)))  # Convierte la lista a número
        digtstsint += 1 # Suma uno
        digitsstr = str(digtstsint) # Convierte el número a string
        new = list(map(int, digitsstr)) # Convierte cada dígito a entero
        return new # Devuelve la nueva lista de enteros

solu = Solution()
resultado = solu.plusOne([1, 4, 3])
print(resultado)

# Argel Jhamir Gonzalez Ontiveros
# 14571

# plusOne: óptimo (sin conversiones a int/str)
# Complejidad: O(n) tiempo en el peor caso, O(1) espacio

class Solution:
    def plusOne(self, digits: list[int]) -> list[int]:
        n = len(digits)  # Tamaño de la lista

        for i in range(n - 1, -1, -1):  # Recorremos desde el final
            if digits[i] < 9:
                digits[i] += 1  # Sumamos 1 si no es 9
                return digits  # No hay acarreo, terminamos
            digits[i] = 0  # Si es 9, lo cambiamos a 0 y seguimos

        return [1] + digits  # Si todos eran 9, agregamos 1 al inicio

solu = Solution()
resultado = solu.plusOne([1, 4, 3])
print(resultado)  # Salida esperada: [1, 4, 4]

"""# Sqrt(x)"""

# Argel Jhamir Gonzalez Ontiveros
# 14571

# mySqrt: fuerza bruta
# Complejidad: O(√x), ya que recorremos desde 0 hasta que i*i>x y el espacio O(1), porque no usamos memoria adicional

class Solution:
    def mySqrt(self, x: int) -> int:
        for i in range(x + 1):  # Recorremos desde 0 hasta x (incluyendo x)
            if i * i == x:      # Si encontramos la raíz exacta
                return i
            elif i * i > x:     # Si nos pasamos, devolvemos el anterior
                return i - 1

solu = Solution()
resultado = solu.mySqrt(16)
print(resultado)

# Argel Jhamir Gonzalez Ontiveros
# 14571

# mySqrt: óptimo (búsqueda binaria)
# Complejidad: O(log x), porque dividimos el rango a la mitad en cada paso, espacio O(1), no usamos estructuras adicionales

class Solution:
    def mySqrt(self, x: int) -> int:
        if x < 2:
            return x  # Casos especiales: raíz de 0 o 1 es el mismo número

        left, right = 0, x

        while left <= right:
            mid = (left + right) // 2
            cuadrado = mid * mid

            if cuadrado == x:
                return mid  # Raíz exacta
            elif cuadrado < x:
                left = mid + 1  # Buscar en la mitad derecha
            else:
                right = mid - 1  # Buscar en la mitad izquierda

        return right  # Parte entera de la raíz cuadrada

solu = Solution()
resultado = solu.mySqrt(16)
print(resultado)

"""# Longest Common Prefix"""

# Argel Jhamir Gonzalez Ontiveros
# 14571

# longestCommonPrefix: fuerza bruta sin while
# Complejidad:
# - Tiempo: O(n * m), donde n = cantidad de palabras y m = longitud mínima
# - Espacio: O(1), porque no usamos estructuras adicionales grandes

class Solution:
    def longestCommonPrefix(self, strs: list[str]) -> str:
        if not strs:
            return ""  # Si la lista está vacía, no hay nada que comparar

        resultado = ""  # Aquí construiremos el prefijo común más largo

        # Recorremos las letras de la primera palabra, posición por posición
        for i in range(len(strs[0])):
            letra = strs[0][i]  # Tomamos la letra actual como referencia

            # Recorremos las demás palabras para comparar esa letra
            for palabra in strs[1:]:
                # Si ya no hay letra en esa posición (palabra más corta)
                # o si la letra no coincide con la de referencia
                if i >= len(palabra) or palabra[i] != letra:
                    return resultado  # Terminamos y devolvemos el prefijo acumulado

            # Si todas las palabras tenían la misma letra en esta posición, la añadimos
            resultado += letra

        # Si nunca hubo diferencias, devolvemos todo el prefijo construido
        return resultado

solu = Solution()
resultado = solu.longestCommonPrefix(["flower", "flow", "flight"])
print(resultado)

# Argel Jhamir Gonzalez Ontiveros
# 14571

# longestCommonPrefix: comparación letra por letra (columna por columna)
# Complejidad: Tiempo: O(n * m), n = cantidad de palabras, m = longitud del prefijo común Espacio: O(1), no se usan estructuras adicionales grandes
# por lo cual es muy parecido al fuerza bruta
class Solution:
    def longestCommonPrefix(self, strs: list[str]) -> str:
        if not strs:
            return ""  # Si la lista está vacía, no hay prefijo

        for i in range(len(strs[0])):  # Recorremos letras por índice (columna)
            letra = strs[0][i]  # Tomamos la letra de referencia

            for palabra in strs[1:]:  # Comparamos con todas las demás palabras
                # Si la letra no está en la palabra o no coincide
                if i >= len(palabra) or palabra[i] != letra:
                    return strs[0][:i]  # Devolvemos todo lo que coincidió hasta antes de fallar

        return strs[0]  # Si nunca falló, toda la primera palabra es el prefijo común

"""# Climb stairs"""

# Argel Jhamir Gonzalez Ontiveros
# 14571

# climbStairs: fuerza bruta
# Complejidad:
# - Tiempo: O(2^n), por loq ue lo hace menos eficiente
# - Espacio: O(n), por la profundidad de la pila

class Solution:
    def climbStairs(self, n: int) -> int:
        # Caso base: si estás en el escalón 0 o 1, solo hay una forma de llegar ahí
        if n == 0 or n == 1:
            return 1

        # Llamada recursiva: suma las formas de subir 1 o 2 peldaños hacia atrás
        return self.climbStairs(n - 1) + self.climbStairs(n - 2)


solu = Solution()
resultado = solu.climbStairs(4)
print(resultado)

# Argel Jhamir Gonzalez Ontiveros
# 14571

# climbStairs: solución optimizada (programación dinámica)
# Complejidad:
# - Tiempo: O(n), solo recorremos del 3 hasta n
# - Espacio: O(1), solo usamos 2 variables (no arreglos)

class Solution:
    def climbStairs(self, n: int) -> int:
        if n == 0 or n == 1:
            return 1  # Solo hay 1 forma de subir 0 o 1 escalón

        a, b = 1, 1  # a = formas para n-2, b = formas para n-1

        for _ in range(2, n + 1):  # Desde el peldaño 2 hasta n
            a, b = b, a + b  # b = formas actuales, a = formas anteriores

        return b  # b es el resultado final: formas para llegar a n

solu=Solution()
resultado=solu.climbStairs(4)
print(resultado)

"""# Two Product"""

# Argel Jhamir Gonzalez Ontiveros
# 14571

# twoProduct: fuerza bruta
# Complejidad:
# - Tiempo: O(n²), porque usamos dos fors
# - Espacio: O(1), porque no se usan estructuras adicionales

class Solution:
    def twoProduct(self, nums: list[int], target: int) -> list[int]:
        # Recorremos cada número en la lista
        for i in range(len(nums)):
            # Comparamos con los siguientes para evitar repetidos o consigo mismo
            for j in range(i + 1, len(nums)):
                # Si el producto da el target, devolvemos los índices
                if nums[i] * nums[j] == target:
                    return [i, j]


solu = Solution()
r = solu.twoProduct([4, 8, 9, 24, 8], 64)
print(r)

# Argel Jhamir Gonzalez Ontiveros
# 14571

# twoProduct: versión optimizada usando diccionario
# Complejidad:
# - Tiempo: O(n), recorremos la lista una sola vez
# - Espacio: O(n), usamos un diccionario para guardar elementos visitados

class Solution:
    def twoProduct(self, nums: list[int], target: int) -> list[int]:
        mapa = {}  # Diccionario para guardar valor: índice

        for i, num in enumerate(nums):  # Recorremos con índice y valor
            if num != 0 and target % num == 0:  # Verificamos que el complemento sea exacto
                complemento = target // num  # Buscamos el número que multiplicado con num da el target
                if complemento in mapa:  # Si ya vimos ese número, devolvemos ambos índices
                    return [mapa[complemento], i]
            mapa[num] = i  # Guardamos el número actual con su índice

# Prueba del método
solu = Solution()
r = solu.twoProduct([4, 8, 9, 24, 8], 64)
print(r)  # Debería imprimir [1, 4] porque 8 * 8 = 64

"""# Valid Parentheses"""

# Argel Jhamir Gonzalez Ontiveros
# 14571

# isValid: fuerza bruta
# Complejidad:
# - Tiempo: O(n), recorre cada carácter una sola vez
# - Espacio: O(n), en el peor caso todos los paréntesis se apilan

class Solution:
    def isValid(self, s: str) -> bool:
        stack = []  # Creamos la pila vacía

        for c in s:  # Recorremos cada carácter de la cadena
            if c == '(' or c == '[' or c == '{':  # Si es paréntesis de apertura
                stack.append(c)  # Lo guardamos en la pila
            else:  # Si es paréntesis de cierre
                if not stack:  # Si no hay con qué emparejar, es inválido
                    return False
                top = stack.pop()  # Sacamos el último abierto
                # Si no hace par correcto, devolvemos False
                if (c == ')' and top != '(') or \
                   (c == ']' and top != '[') or \
                   (c == '}' and top != '{'):
                    return False

        return not stack  # Si la pila quedó vacía, es válido

# Prueba del método
solu = Solution()
print(solu.isValid("(){}[]"))   # True
print(solu.isValid("({[})]"))   # False
print(solu.isValid("(()"))      # False
print(solu.isValid("{[()]}"))   # True

# Argel Jhamir Gonzalez Ontiveros
# 14571

# isValid: optmizado
# Complejidad:
# - Tiempo: O(n), recorremos la cadena una sola vez
# - Espacio: O(n), en el peor caso se guardan todos los paréntesis de apertura

class Solution:
    def isValid(self, s: str) -> bool:
        stack = []  # Pila vacía para almacenar los abiertos
        pares = {')': '(', ']': '[', '}': '{'}  # Diccionario de pares válidos

        for c in s:  # Recorremos cada carácter
            if c in pares.values():  # Si es de apertura, lo metemos a la pila
                stack.append(c)
            elif c in pares:  # Si es de cierre
                if not stack or stack[-1] != pares[c]:  # Si la pila está vacía o no hace par
                    return False
                stack.pop()  # Eliminamos el par correcto
            else:
                return False  # Si hay otro carácter no válido, retornamos False

        return not stack  # Al final, la pila debe estar vacía si todo estuvo emparejado

# Prueba del método
solu = Solution()
print(solu.isValid("(){}[]"))   # True
print(solu.isValid("({[})]"))   # False
print(solu.isValid("(()"))      # False
print(solu.isValid("{[()]}"))   # True